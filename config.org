# -*- mode: org; -*-
#+AUTHOR: Sohaib Mahmood
#+TITLE: GNU Emacs Configuration
#+PROPERTY: header-args:emacs-lisp :tangle ./config.el :mkdirp yes
* Table of Content :TOC:
- [[#about][About]]
- [[#core][Core]]
  - [[#defaults][Defaults]]
  - [[#functions][Functions]]
  - [[#packages][Packages]]
  - [[#environment][Environment]]
  - [[#authentication][Authentication]]
  - [[#xdg-base-directory-specification][XDG Base Directory Specification]]
  - [[#saving-configuration][Saving Configuration]]
- [[#appearance][Appearance]]
  - [[#defaults-1][Defaults]]
  - [[#theme][Theme]]
  - [[#fonts][Fonts]]
  - [[#icons][Icons]]
  - [[#menus][Menus]]
  - [[#modeline][Modeline]]
  - [[#dashboard][Dashboard]]
- [[#management][Management]]
  - [[#buffers][Buffers]]
  - [[#windows][Windows]]
  - [[#minibuffer][Minibuffer]]
  - [[#files][Files]]
  - [[#projects][Projects]]
- [[#editing][Editing]]
  - [[#defaults-2][Defaults]]
  - [[#deletion][Deletion]]
  - [[#visual-clarity][Visual Clarity]]
  - [[#navigation][Navigation]]
  - [[#search-and-replace][Search and Replace]]
  - [[#linguistics][Linguistics]]
  - [[#multi-edit][Multi-Edit]]
  - [[#undoredo][Undo/Redo]]
  - [[#sudo][Sudo]]
- [[#development][Development]]
  - [[#tree-sitter][Tree-sitter]]
  - [[#version-control][Version Control]]
  - [[#language-server][Language Server]]
  - [[#lintersdocumentation][Linters/Documentation]]
  - [[#snippets][Snippets]]
  - [[#virtualization][Virtualization]]
- [[#org][Org]]
  - [[#defaults-3][Defaults]]
  - [[#faces][Faces]]
  - [[#agenda][Agenda]]
  - [[#capture][Capture]]
  - [[#note-taking][Note Taking]]
  - [[#time-management][Time Management]]
  - [[#money-management][Money Management]]
- [[#languages][Languages]]
  - [[#defaults-4][Defaults]]
  - [[#yaml][Yaml]]
  - [[#python][Python]]
  - [[#cc][C/C++]]
  - [[#go][Go]]
  - [[#rust][Rust]]
  - [[#bash][Bash]]

* About
My personal Emacs configuration.

This configuration is inspired by the following repositories:
- https://github.com/brett-lempereur/.emacs.d
- https://github.com/rememberYou/.emacs.d
* Core
This section contains the core packages and configurations needed to get started with GNU Emacs.
** Defaults
Sensible default values that I use.
#+begin_src emacs-lisp
  (setq user-emacs-directory (expand-file-name (format "%s/emacs" "~/.config")))
  (setq-default
   initial-major-mode 'text-mode                    ; Start *scratch* in text mode
   ad-redefinition-action 'accept                   ; Silence warnings for redefinition
   byte-compile-warnings '(cl-functions)            ; Remove pesky CL warning
   cursor-in-non-selected-windows nil               ; Hide the cursor in inactive windows
   display-time-default-load-average nil            ; Don't display load average
   help-window-select t                             ; Focus new help windows when opened
   load-prefer-newer t                              ; Prefer the newest version of a file
   read-process-output-max (* 1024 1024)            ; Increase the amount of data reads from the process
   scroll-conservatively most-positive-fixnum       ; Always scroll by one line
   select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
   user-full-name "Sohaib Mahmood"                  ; Set the full name of the current user
   user-mail-address "soh.mahmood@fastmail.com"     ; Set the email address of the current user
   find-file-visit-truename t                       ; Always follow the symlinks
   view-read-only t                                 ; Always open read-only buffers in view-mode
   save-interprogram-paste-before-kill t            ; Save to kill-ring copying something from outside emacs
   confirm-kill-processes nil                       ; Don't prompt about sub-processes when exiting emacs
   confirm-kill-emacs 'y-or-n-p)                    ; Confirm to kill session
  (fset 'yes-or-no-p 'y-or-n-p)                     ; Replace yes/no prompts with y/n
  ;; Hard set emacs configuration directory
#+end_src
** Functions
Some useful global functions that we will use across the configuration
#+begin_src emacs-lisp
  (defun emacs.d (path)
    "Return the full path pointing to user-emacs-directory"
    (expand-file-name path user-emacs-directory))
  (defun smahm/mkdir (dir-path)
    "Make directory in DIR-PATH if it doesn't exist."
    (unless (file-exists-p dir-path)
      (make-directory dir-path t)))
  (defun smahm/location ()
    "Return 'home' if system-name starts with 'sm-', otherwise return 'work'."
    (if (string-match-p "^sm-" (system-name))
        "home"
      "work"))
  (defun smahm/reload-config ()
    "Reload init file, which will effectively reload everything"
    (interactive)
    (load-file (expand-file-name "init.el" user-emacs-directory)))
  (global-set-key (kbd "<f5>") 'smahm/reload-config)
  (defun smahm/revert-buffer-no-confirm ()
    "Revert buffer without confirmation."
    (interactive)
    (revert-buffer :ignore-auto :noconfirm))

#+end_src
** Packages
To manage packages, I use [[https://github.com/jwiegley/use-package/][use-package]].
*** Package Sources
To install packages, it is useful to configure the package sources.
#+begin_src emacs-lisp
  (setq package-archives '(("elpa" . "https://elpa.gnu.org/packages/")
                           ("melpa" . "https://melpa.org/packages/")
                           ("nongnu" . "https://elpa.nongnu.org/nongnu/")))
  ;; Highest number gets priority (what is not mentioned has priority 0)
  (setq package-archive-priorities
        '(("gnu-elpa" . 3)
          ("melpa" . 2)
          ("nongnu" . 1)))
#+end_src
*** Package Management
Contrary to what some users might think, use-package is not a package
manager. To download and use packages that are not available in package sources,
#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  ;; Since Emacs version 29 use-package is built-in, so the previous
  ;; three lines can be avoided, but still keeping as it's harmless
  (require 'use-package)
#+end_src
*** Package Configuration
To manage the package configurations with use-package, we add some required libraries
#+begin_src emacs-lisp
  (setq use-package-always-ensure t)
  (use-package delight) ;; Used to customise the mode names displayed in the mode line
  (use-package s) ;; Used for more string manipulation functions
#+end_src
** Environment
By default not all environment variables are copied to Emacs. This package ensures proper synchronization between the two.
#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :custom
  (epg-pinentry-mode 'loopback)
  (exec-path-from-shell-variables '("PATH" "SHELL" "GOPATH"))
  :config
  (setenv "SSH_AUTH_SOCK" (string-chop-newline (shell-command-to-string "gpgconf --list-dirs agent-ssh-socket")))
  (exec-path-from-shell-initialize))
#+end_src
Having a good terminal emulator is vital to my flow of using Emacs. I found the eat package to be the best in this regard.
#+begin_src emacs-lisp
  (use-package eat
    :config
    (add-hook 'eat-mode-hook (lambda () (setq-local global-hl-line-mode nil)))
    (define-key eat-semi-char-mode-map (kbd "M-o") nil) ;; M-o used to switch windows
    (define-key eat-semi-char-mode-map (kbd "M-u") nil) ;; M-u used to fullscreen buffer
    :bind
    ("C-c t" . eat))
#+end_src
** Authentication
I use a GPG key stored in a Yubikey for most of my authentication
#+begin_src emacs-lisp
  (use-package epa-file
    :ensure nil
    :init
    (epa-file-enable))
#+end_src
** XDG Base Directory Specification
To keep the user’s home and the ~/.config/emacs folder as clean as possible, I follow the XDG base directory specification. Be careful that GNU Emacs will not create the appropriate folders if they do not exist. Therefore, it is necessary to create them yourself.
#+begin_src emacs-lisp
  (defvar xdg-state (getenv "XDG_STATE_HOME")
    "The XDG bin base directory.")

  (defvar xdg-cache (getenv "XDG_CACHE_HOME")
    "The XDG cache base directory.")

  (defvar xdg-config (getenv "XDG_CONFIG_HOME")
    "The XDG config base directory.")

  (defvar xdg-data (getenv "XDG_DATA_HOME")
    "The XDG data base directory.")

  (defvar xdg-lib (getenv "XDG_LIB_HOME")
    "The XDG lib base directory.")
#+end_src
*** No Littering
The default paths used to store configuration files and persistent data are not consistent across Emacs packages. This isn’t just a problem with third-party packages but even with built-in packages. The following package helps sort that out.
#+begin_src emacs-lisp
  (use-package no-littering
	:init
	(setq no-littering-etc-directory (expand-file-name (format "%s/emacs/etc/" xdg-data)))
	(setq no-littering-var-directory (expand-file-name (format "%s/emacs/var/" xdg-data)))
	:config
	(let ((dir (expand-file-name (format "%s/emacs/etc/" xdg-cache))))
	  (smahm/mkdir dir)
	  (setq url-cookie-file dir))
	(setq custom-file (no-littering-expand-etc-file-name "custom.el"))
	(when (file-exists-p custom-file) (load custom-file))
	(let ((dir (no-littering-expand-var-file-name "lock-files/")))
	  (smahm/mkdir dir)
	  (setq lock-file-name-transforms `((".*" ,dir t)))))
#+end_src
** Saving Configuration
A good practice is to use an .org file to modify your GNU Emacs configuration
with org-mode and to load this configuration via an .el file. This way you can
maintain an org-mode configuration and still get a faster load.

Using the [[https://github.com/jwiegley/emacs-async][async]] package and the org-babel-tangle command, the code below will
executes org-babel-tangle asynchronously when config.org is saved, to update the
config.el file. From then on, you only need to add a add the smahm/config-tangle
function to the after-save hook and specify the loading of the config.el file
into the init.el file.

#+begin_src emacs-lisp
  (use-package async
	:hook (after-save . smahm/config-tangle)
	:preface
	(defvar config-file (expand-file-name "config.org" user-emacs-directory)
	  "The configuration file.")
	(defvar config-last-change (nth 5 (file-attributes config-file))
	  "The last modification time of the configuration file.")
	(defvar show-async-tangle-results nil
	  "Keep *emacs* async buffers around for later inspection.")
	(defun smahm/config-tangle ()
	  "Tangle the org file asynchronously."
	  (when (smahm/config-updated)
		(setq config-last-change
			  (nth 5 (file-attributes config-file)))
		(smahm/async-babel-tangle config-file)))
	(defun smahm/config-updated ()
	  "Check if the configuration file has been updated since the last time."
	  (time-less-p config-last-change
				   (nth 5 (file-attributes config-file))))
	(defun smahm/async-babel-tangle (org-file)
	  "Tangle the org file asynchronously."
	  (let ((init-tangle-start-time (current-time))
			(file (buffer-file-name))
			(async-quiet-switch "-q"))
		(async-start
		 `(lambda ()
			(require 'org)
			(org-babel-tangle-file ,org-file))
		 (unless show-async-tangle-results
		   `(lambda (result)
			  (if result
				  (message "[✓] %s successfully tangled (%.2fs)"
						   ,org-file
						   (float-time (time-subtract (current-time)
													  ',init-tangle-start-time)))
				(message "[✗] %s as tangle failed." ,org-file))))))))
#+end_src
* Appearance
A color scheme and decent font not only helps beautify emacs but also helps readablity
** Defaults
Sensible default values that I use.
#+begin_src emacs-lisp
  (setq-default
   inhibit-startup-screen t                         ; Disable start-up screen
   initial-scratch-message ""                       ; Empty the initial *scratch* buffer
   make-pointer-invisible t                         ; Hide mouse pointer when typing
   cursor-type 'bar)                                ; Cursor type should be bar not block
  (blink-cursor-mode 1)                             ; Blink the cursor
  (column-number-mode 1)                            ; Show the column number
  (global-hl-line-mode)                             ; Hightlight current line
  (show-paren-mode 1)                               ; Show the parent
  (when window-system                               ; No menu/scroll/tool bars
    (menu-bar-mode -1)
    (scroll-bar-mode -1)
    (tool-bar-mode -1)
    (tooltip-mode -1))
#+end_src
** Theme
I switch themes quite often but usually I prefer high contrast dark themes.
#+begin_src emacs-lisp
  (use-package doom-themes
    :if (and (display-graphic-p) (string= (smahm/location) "home"))
    :custom
    (doom-themes-enable-bold t)
    (doom-themes-enable-italic t)
    :config
    (doom-themes-visual-bell-config)
    :init
    (load-theme 'doom-homage-black t))
#+end_src

Since we do not do things by halves, it is also interesting to visually
differentiate "real" buffers (e.g., buffers that contain our work) from "unreal"
buffers (e.g., popups) by giving the latter a darker color. From then on,
[[https://github.com/hlissner/emacs-solaire-mode][solar-mode]] is the ideal package.

#+begin_src emacs-lisp
  (use-package solaire-mode
    :defer 0.1
    :custom (solaire-mode-remap-fringe t)
    :config (solaire-global-mode))
#+end_src
** Fonts
Spending most of our time on GNU Emacs, it is important to use a font that will
make our reading easier. JetBrainsMono is one of the best monospaced font.
Since we are going to install NerdIcons we might as well install the NerdFont version.
#+begin_src emacs-lisp
  (set-face-attribute 'default nil :font "JetBrainsMonoNerdFont 14")
  (set-fontset-font t 'latin "Noto Sans")
#+end_src
** Icons
To integrate icons with the modeline and other packages, [[https://github.com/domtronn/all-the-icons.el/][nerd-icons]] is my icons
package of choice.
#+begin_src emacs-lisp
  (use-package nerd-icons
    :custom
    (nerd-icons-font-family "JetBrains Mono Nerd Font"))
#+end_src
** Menus
GNU Emacs has so many commands per mode that it is tedious to remember all the
keybindings for quick access.  Fortunately, [[https://github.com/abo-abo/hydra][hydra]] allows you to create menu
commands and on the basis of a popup, display the commands you have associated
with it.
#+begin_src emacs-lisp
  (use-package hydra)
  (use-package major-mode-hydra
	:after hydra
	:preface
	(defun with-mdicon (icon str &optional height v-adjust face)
	  "Display an icon from nerd-icons."
	  (s-concat (nerd-icons-mdicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))
	(defun with-faicon (icon str &optional height v-adjust face)
	  "Display an icon from Font Awesome icon."
	  (s-concat (nerd-icons-faicon icon ':v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))
	(defun with-fileicon (icon str &optional height v-adjust face)
	  "Display an icon from the Atom File Icons package."
	  (s-concat (nerd-icons-flicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str))
	(defun with-octicon (icon str &optional height v-adjust face)
	  "Display an icon from the GitHub Octicons."
	  (s-concat (nerd-icons-octicon icon :v-adjust (or v-adjust 0) :height (or height 1) :face face) " " str)))
#+end_src
** Modeline
[[https://github.com/dbordak/telephone-line/][Telephone Line]] is a minimal and customizable modeline and seems to work best with nyan mode
#+begin_src emacs-lisp
  (use-package telephone-line
    :config
    (setq telephone-line-lhs
          '((accent . (telephone-line-vc-segment
                       telephone-line-erc-modified-channels-segment))
            (nil    . (telephone-line-buffer-segment
                       telephone-line-nyan-segment))))
    (setq telephone-line-rhs
          '((nil    . (telephone-line-misc-info-segment))
            (accent . (telephone-line-major-mode-segment))
            (evil   . (telephone-line-airline-position-segment))))
    (telephone-line-mode 1))
#+end_src

Must have eye candy =)
#+begin_src emacs-lisp
  (use-package nyan-mode
  :config
  (nyan-mode))
#+end_src

De-clutter major/minor buffer information into a single menu
#+begin_src emacs-lisp
  (use-package minions
    :config
    (minions-mode 1))
#+end_src

** Dashboard
Organization is even more important in the 21st century than it was before. What
could be better than launching GNU Emacs with a dashboard that lists the tasks
of the week with org-agenda and a list of projects we have recently contributed
to with projectile. To our delight the [[https://github.com/emacs-dashboard/emacs-dashboard][dashboard]] package offers these features
and more.

#+begin_src emacs-lisp
    (use-package dashboard
      :custom
      (dashboard-banner-logo-title "Get Busy Living Or Get Busy Dying!")
      (dashboard-center-content t)
      (dashboard-items '((agenda)
                         (projects . 3)
                         (recents   . 3)))
      (dashboard-set-file-icons t)
      (dashboard-set-footer nil)
      (dashboard-set-heading-icons t)
      (dashboard-set-navigator t)
      (dashboard-startup-banner 'logo)
      :config (dashboard-setup-startup-hook))
#+end_src
* Management
Section dedicated to managing buffers, windows, the minibuffer, files and projects on GNU Emacs to provide a more pleasant experience.
** Buffers
Buffers can quickly become a mess to manage. To manage them better, I use the ibuffer built-in package instead of buffer-menu, to have a nicer visual interface with a syntax color. I also include additional functions from [[https://emacsredux.com/tags/#crux][Emacs Redux]] that I have found useful.
In addition, some buffers may contain useful temporary information that should not be killed by accident. I make sure to set the buffers *scratch* and *Messages* to read-only.
#+begin_src emacs-lisp
  (use-package ibuffer
    :ensure nil
    :preface
    (defvar protected-buffers '("*scratch*" "*Messages*")
      "Buffer that cannot be killed.")
    (defun smahm/protected-buffers ()
      "Protect some buffers from being killed."
      (dolist (buffer protected-buffers)
        (with-current-buffer buffer
          (emacs-lock-mode 'kill))))
    (defun smahm/rename-file-and-buffer ()
      "Rename the current buffer and file it is visiting."
      (interactive)
      (let ((filename (buffer-file-name)))
        (if (not (and filename (file-exists-p filename)))
            (message "Buffer is not visiting a file!")
          (let ((new-name (read-file-name "New name: " filename)))
            (cond
             ((vc-backend filename) (vc-rename-file filename new-name))
             (t
              (rename-file filename new-name t)
              (set-visited-file-name new-name t t)))))))
    (defun smahm/delete-file-and-buffer ()
      "Kill the current buffer and deletes the file it is visiting."
      (interactive)
      (let ((filename (buffer-file-name)))
        (when filename
          (if (vc-backend filename)
              (vc-delete-file filename)
            (progn
              (delete-file filename)
              (message "Deleted file %s" filename)
              (kill-buffer))))))
    (defun smahm/kill-other-buffers ()
      "Kill other buffers except current one and protected buffers."
      (interactive)
      (eglot-shutdown-all)
      (mapc 'kill-buffer
            (cl-remove-if
             (lambda (x)
               (or
                (eq x (current-buffer))
                (member (buffer-name x) protected-buffers)))
             (buffer-list)))
      (delete-other-windows))
    :bind (([remap kill-buffer] . kill-current-buffer))
    :init (smahm/protected-buffers))
#+end_src
In addition we can override eamcs default mechanism for making buffer name unique
#+begin_src emacs-lisp
  (use-package uniquify
    :ensure nil
    :config
    (setq uniquify-buffer-name-style 'forward)
    (setq uniquify-separator "/")
    (setq uniquify-after-kill-buffer-p t)
    (setq uniquify-ignore-buffers-re "^\\*"))
#+end_src

We can add a menu for buffer options as well
#+begin_src emacs-lisp
  (pretty-hydra-define hydra-buffer
    (:hint nil :forein-keys warn :quit-key "q" :title (with-faicon "nf-fa-buffer" "Buffers" 1 -0.05))
    ("Buffer"
     (("a" ibuffer "all")
      ("r" smahm/rename-file-and-buffer "rename")
      ("d" smahm/delete-file-and-buffer "delete")
      ("o" smahm/kill-other-buffers "only")
      ("s" sudo-edit-current-file "sudo"))))
  (global-set-key (kbd "C-c b") 'hydra-buffer/body)
  (global-unset-key (kbd "C-x C-b"))
#+end_src
** Windows
Most of the time, I want to split a window and put the focus on it to perform an action. By default GNU Emacs does not give the focus to this new window. I have no idea why this is not the default behavior, but we can easily set this behavior.

#+begin_src emacs-lisp
	  (use-package window
		:ensure nil
		:preface
		(defun smahm/hsplit-last-window ()
		  "Focus to the last created horizontal window."
		  (interactive)
		  (split-window-horizontally)
		  (other-window 1))
		(defun smahm/vsplit-last-window ()
		  "Focus to the last created vertical window."
		  (interactive)
		  (split-window-vertically)
		  (other-window 1))
		(defun smahm/toggle-fullscreen-window ()
		  "Maximize buffer"
		  (interactive)
		  (if (= 1 (length (window-list)))
			  (jump-to-register '_)
			(progn
			  (window-configuration-to-register '_)
			  (delete-other-windows))))
		(defun smahm/transpose-windows ()
		  "Transpose two windows.  If more or less than two windows are visible, error."
		  (interactive)
		  (unless (= 2 (count-windows))
			(error "There are not 2 windows."))
		  (let* ((windows (window-list))
				 (w1 (car windows))
				 (w2 (nth 1 windows))
				 (w1b (window-buffer w1))
				 (w2b (window-buffer w2)))
			(set-window-buffer w1 w2b)
			(set-window-buffer w2 w1b)))
		:bind (("C-x 2" . smahm/vsplit-last-window)
			   ("C-x 3" . smahm/hsplit-last-window)
			   ("M-u" . smahm/toggle-fullscreen-window)))
#+end_src

The way I move between several windows in GNU Emacs is by indicating the number
of the window I want to move to. Most people use [[https://github.com/abo-abo/ace-window][ace-window]], but I prefer
[[https://github.com/dimitri/switch-window][switch-window]] which displays the window number while hiding its content. I find
this behavior more convenient than moving from window to window to get to the
one we are looking for.

#+begin_src emacs-lisp
  (use-package switch-window
    :bind (("M-o" . switch-window)))
#+end_src

There are times when I would like to bring back a windows layout with their
content. With the winner-undo and winner-redo commands from the built-in winner
package, I can easily do that.

#+begin_src emacs-lisp
  (use-package winner
    :ensure nil
    :config (winner-mode))
#+end_src

We can add a menu for window options as well
#+begin_src emacs-lisp
  (pretty-hydra-define hydra-windows
	(:hint nil :forein-keys warn :quit-key "q" :title (with-faicon "nf-fa-windows" "Windows" 1 -0.05))
	("Window"
	 (("b" balance-windows "balance")
	  ("c" recenter-top-bottom "center")
	  ("t" smahm/transpose-windows "transpose")
	  ("i" enlarge-window "heighten")
	  ("j" shrink-window-horizontally "narrow")
	  ("k" shrink-window "lower")
	  ("u" winner-undo "undo")
	  ("r" winner-redo "redo")
	  ("l" enlarge-window-horizontally "widen")
	  ("s" switch-window-then-swap-buffer "swap" :color teal))
	 "Zoom"
	 (("-" text-scale-decrease "out")
	  ("+" text-scale-increase "in")
	  ("=" (text-scale-increase 0) "reset"))))
  (global-set-key (kbd "C-c w") 'hydra-windows/body)
#+end_src
** Minibuffer
*** Completion
Having a good minibuffer experience is important on GNU Emacs since it is one of the elements we will frequently interact with. We start with vertico which is a vertical completion system that is very performant and minimalistic.

#+begin_src emacs-lisp
  (use-package vertico
    :init (vertico-mode)
    :custom (vertico-cycle t)
    :custom-face (vertico-current ((t (:background "#1d1f21")))))
#+end_src

To enable richer annotations (e.g., summary documentation of the functions and
variables, as well as having the size and the last consultation of the files)
for minibuffer completions, [[https://github.com/minad/marginalia/][marginalia]] is awesome.

#+begin_src emacs-lisp
  (use-package marginalia
    :after vertico
    :init (marginalia-mode)
    :custom
    (marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))
#+end_src

By default, vertico sorts the candidates according to their history position,
then by length and finally by alphabetical. To improves searching across
completion (e.g., by filter expressions separated by spaces), you should
use [[https://github.com/oantolin/orderless][orderless]] (or [[https://github.com/raxod502/prescient.el][prescient]]).

#+begin_src emacs-lisp
  (use-package orderless
    :custom
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles . (partial-completion)))))
    (completion-styles '(orderless)))
#+end_src

We can enhance buffer/minibuffer completion by adding a small completion popup with a neat package called [[https://github.com/minad/corfu][corfu]].
#+begin_src emacs-lisp
  (use-package corfu
    :custom
    (corfu-cycle t)
    (corfu-auto t)
    (corfu-auto-prefix 1)
    (corfu-auto-delay 0)
    (corfu-quit-no-match 'separator)
    (corfu-preview-current t)
    (corfu-on-exact-match nil)
    :config
    (setq completion-cycle-threshold 3)
    (setq tab-always-indent 'complete))
  (use-package nerd-icons-corfu
    :init
    (add-to-list 'corfu-margin-formatters #'nerd-icons-corfu-formatter))
#+end_src

Better keyboard-quit
From https://github.com/doomemacs/doomemacs/blob/master/lisp/doom-keybinds.el#L101
#+begin_src emacs-lisp
  (defvar smahm-escape-hook nil
    "A hook run when C-g is pressed (or ESC in normal mode, for evil users).

      More specifically, when `smahm/escape' is pressed. If any hook returns non-nil,
      all hooks after it are ignored.")

  (defun smahm/escape (&optional interactive)
    "Run `smahm-escape-hook'."
    (interactive (list 'interactive))
    (let ((inhibit-quit t))
      (cond ((minibuffer-window-active-p (minibuffer-window))
             ;; quit the minibuffer if open.
             (when interactive
               (setq this-command 'abort-recursive-edit))
             (abort-recursive-edit))
            ;; Run all escape hooks. If any returns non-nil, then stop there.
            ((run-hook-with-args-until-success 'smahm-escape-hook))
            ;; don't abort macros
            ((or defining-kbd-macro executing-kbd-macro) nil)
            ;; Back to the default
            ((unwind-protect (keyboard-quit)
               (when interactive
                 (setq this-command 'keyboard-quit)))))))
  (global-set-key [remap keyboard-quit] #'smahm/escape)
#+end_src

And finally, [[https://github.com/justbur/emacs-which-key][which-key]] helps show available commands in the minibuffer
#+begin_src emacs-lisp
  (use-package which-key
    :ensure nil
    :init
    (which-key-mode))
#+end_src

*** Actions
[[https://github.com/minad/consult][consult]] is used for search and navigation but a lot of it's actions start from the minibuffer
#+begin_src emacs-lisp
  (use-package consult
    :init
    (global-unset-key (kbd "C-s"))
    :custom
    (consult-yank-rotate 1)
    :bind (("C-s S" . isearch-forward)
           ("C-s R" . isearch-backward)
           ("C-s s" . consult-line)
           ("C-s l" . consult-goto-line)
           ("C-s i" . consult-imenu)
           ("C-s r" . consult-ripgrep)
           ("C-s f" . consult-fd)
           ("M-y"   . consult-yank-from-kill-ring)
           ("C-x b" . consult-buffer)))
#+end_src

[[https://github.com/oantolin/embark][embark]] is great if like me you like to interact directly with your
files (e.g., for renaming, deleting and copying) through your completion system
without having to go through dired.
#+begin_src emacs-lisp
  (use-package embark-consult
    :bind ("C-." . embark-act))
  (use-package embark
  	:bind ("C-." . embark-act))
#+end_src
** Files
*** Backups
It is important to have file backups available with GNU Emacs. The following configuration forces a backup on every save of a file.
#+begin_src emacs-lisp
  (setq-default
   vc-make-backup-files t                           ; backup versioned files
   version-control t                                ; version numbers for backup files
   kept-new-versions 100                            ; Number of newest versions to keep
   kept-old-versions 100                            ; Number of oldest versions to keep
   delete-old-versions t                            ; Don't ask to delete excess backup versions
   backup-by-copying t)                             ; Copy all files, don't rename them
  (defun force-backup-of-buffer ()
	"Make a special 'per session' backup at the first save of each emacs session and a per-save backup on each subsequent save."
	(let* ((per-save-dir (expand-file-name (file-name-as-directory (format "%s/emacs/backups/per-save/" xdg-data))))
		   (per-session-dir (expand-file-name (file-name-as-directory (format "%s/emacs/backups/per-session/" xdg-data)))))
	  (smahm/mkdir per-save-dir)
	  (smahm/mkdir per-session-dir)
	  (setq backup-directory-alist `(("." . ,per-save-dir)))
	  (when (not buffer-backed-up)
		(let ((backup-directory-alist `(("." . ,per-session-dir)))
			  (kept-new-versions 3))
		  (backup-buffer)))
	  (let ((buffer-backed-up nil))
		(backup-buffer))))
  (add-hook 'before-save-hook 'force-backup-of-buffer)
#+end_src

[[https://github.com/lewang/backup-walker][backup-walker]] allows us to view the diff between backups and selectively restore one
#+begin_src emacs-lisp
  (use-package backup-walker)
#+end_src

*** Saving
Let's change where Emacs stores auto-saves
#+begin_src emacs-lisp
  (setq-default
   auto-save-default t                           ; Enable auto-save
   auto-save-timeout 30                          ; Auto-save if idle for 30 seconds
   auto-save-interval 300)                       ; Auto-save after having typed 300 characters
  (let ((dir (expand-file-name (file-name-as-directory (expand-file-name (format "%s/emacs/auto-save/" xdg-cache))))))
    (smahm/mkdir dir)
    (setq auto-save-file-name-transforms `((".*" ,dir t))))
#+end_src

Sometimes you may want to discard your changes to a file and revert to the saved
version of this file.

#+begin_src emacs-lisp
  (use-package autorevert
    :ensure nil
    :delight auto-revert-mode
    :bind ("C-x R" . revert-buffer)
    :custom (auto-revert-verbose nil)
    :config (global-auto-revert-mode))
#+end_src

There are times when it is necessary to remember a command. The savehist
built-in package allows you to save commands in a file so that you can run them
again later.

#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :custom
    (history-delete-duplicates t)
    (history-length 25)
    (savehist-file (expand-file-name (format "%s/emacs/history" xdg-cache)))
    :config (savehist-mode))
#+end_src
*** Recent
It is also useful to have easy access to recently modified files.
#+begin_src emacs-lisp
  (use-package recentf
    :ensure nil
    :bind ("C-x r" . recentf-open-files)
    :init (recentf-mode)
    :custom
    (recentf-exclude (list "/scp:"
                           "/ssh:"
                           "/sudo:"
                           "/tmp/"
                           "~$"
                           "COMMIT_EDITMSG"))
    (recentf-max-menu-items 15)
    (recentf-max-saved-items 200)
    (recentf-save-file (expand-file-name (format "%s/emacs/recentf" xdg-cache)))
    ;; Save recent files every 5 minutes to manage abnormal output.
    :config (run-at-time nil (* 5 60) 'recentf-save-list))
#+end_src
*** Trash
I'd like files to be trashed instead of permanently deleted
#+begin_src emacs-lisp
  (defun empty-trash ()
    "Empty the trash"
    (interactive)
    (shell-command "trash-empty -f"))

  (setq trash-directory (expand-file-name (format "%s/Trash/files" xdg-data)))
  (setq delete-by-moving-to-trash t)
#+end_src
*** Dired
Dirvish is an improved version built on Emacs's builtin file manager Dired.
The following tools are also recommended to use with dirvish:
- fd as a faster alternative to find
- imagemagick for image preview
- poppler | pdf-tools for pdf preview
- ffmpegthumbnailer for video preview
- mediainfo for audio/video metadata generation
- tar and unzip for archive files preview
#+begin_src emacs-lisp
    (use-package dirvish
      :init
      (dirvish-override-dired-mode)
      :custom
      (dirvish-quick-access-entries
       '(("h" "~/"                                          "Home")
         ("d" "~/dump/"                                     "Downloads")
         ("w" "~/workstation"                               "Workstation")
         ("p" "~/media/pictures/"                           "Pictures")
         ("m" "/mnt/"                                       "Drives")
         ("t" "~/.local/share/Trash/files/"                 "TrashCan")
         ("r" "/"                                           "Root")))
      :config
      (setf dirvish-reuse-session nil)
      ;; (setq dirvish-mode-line-format
      ;;       '(:left (sort symlink) :right (omit yank index)))
      (setq dirvish-use-header-line 'global)
      (setq dirvish-header-line-format
            '(:left (path) :right (free-space))
            dirvish-mode-line-format
            '(:left (sort file-time " " file-size symlink) :right (omit yank index)))
      (setq dirvish-attributes
        '(vc-state subtree-state nerd-icons collapse git-msg file-time file-size))
      (setq dirvish-subtree-state-style 'nerd)
      (setq dired-listing-switches
            "-l --almost-all --human-readable --group-directories-first --no-group")
      :bind
      (("<f1>" . dirvish-side)
       :map dirvish-mode-map
       ("M-p" . dired-up-directory)
       ("M-n" . dired-find-file)
       ("M-d" . empty-trash)
       ("a"   . dirvish-quick-access)
       ("f"   . dirvish-file-info-menu)
       ("y"   . dirvish-yank-menu)
       ("N"   . dirvish-narrow)
       ("^"   . dirvish-history-last)
       ("h"   . dirvish-history-jump)
       ("s"   . dirvish-quicksort)
       ("TAB" . dirvish-subtree-toggle)
       ("M-f" . dirvish-history-go-forward)
       ("M-b" . dirvish-history-go-backward)))
#+end_src
*** Menu
We can add a menu for file options as well
#+begin_src emacs-lisp
  (defun smahm/find-file-with-default-path (path)
    (interactive)
    (let ((file-name-as-directory path))
      (call-interactively 'find-file)))
  (pretty-hydra-define hydra-file
    (:hint nil :color teal :quit-key "q" :title (with-octicon "nf-oct-file_symlink_file" "Files" 1 -0.05))
    ("Sandbox"
     (("sp" (find-file "~/workstation/projects/sandbox/python/main.py") "python")
      ("sc" (find-file "~/workstation/projects/sandbox/c/main.c") "C")
      ("sb" (find-file "~/workstation/projects/sandbox/bash/main.sh") "bash")
      ("sg" (find-file "~/workstation/projects/sandbox/go/main.go") "go")
      ("sr" (find-file "~/workstation/projects/sandbox/rust/main.rs") "rust")
      ("sd" (find-file "~/workstation/projects/sandbox/docker/Dockerfile") "docker")
      ("sv" (find-file "~/workstation/projects/sandbox/vagrant/Vagrantfile") "vagrant"))
     "Config"
     (("cbb" (find-file "~/.bashrc") "bashrc")
      ("cba" (find-file (format "%s/bash/bash_alias" xdg-state)) "bash alias")
      ("cbe" (find-file (format "%s/bash/bash_environment" xdg-state)) "bash env")
      ("cbf" (find-file (format "%s/bash/bash_function" xdg-state)) "bash func")
      ("ce" (find-file (format "%s/emacs/config.org" xdg-config)) "emacs")
      ("ci" (find-file (format "%s/i3/config" xdg-config)) "i3")
      ("cp" (find-file (format "%s/polybar/config.ini" xdg-config)) "polybar")
      ("ca" (find-file (format "%s/alacritty/alacritty.toml" xdg-config)) "alacritty")
      ("cg" (find-file (format "%s/git/config" xdg-config)) "git")
      ("cs" (find-file (format "%s/ssh/config" xdg-config)) "ssh")
      ("cz" (find-file (format "%s/zathura/zathurarc" xdg-config)) "zathura"))))
  (global-set-key (kbd "C-x f") 'find-file)
  (global-set-key (kbd "C-c f") 'hydra-file/body)
#+end_src
** Projects
I have found the built-in project.el a suitable replacement now for projectile.
#+begin_src emacs-lisp
  (use-package project
    :ensure nil
    :config
    (customize-set-variable 'project-find-functions (list #'project-try-vc #'smahm/project-try-local))
    (cl-defmethod project-root ((project (head local)))
      "Return root directory of current PROJECT."
      (cdr project))
    (defun smahm/project-try-local (dir)
      "Determine if DIR is a non-Git project.
       DIR must include a .project file to be considered a project."
      (let ((root (locate-dominating-file dir ".project")))
        (when root
          (cons 'local root))))
    (defun smahm/project-save-all-buffers (&optional proj arg)
      "Save all file-visiting buffers in PROJ without asking."
      (interactive)
      (let* ((proj (or proj (project-current)))
             (buffers (project-buffers (project-current))))
        (dolist (buf buffers)
          ;; Act on base buffer of indirect buffers, if needed.
          (with-current-buffer (or (buffer-base-buffer buf) buf)
            (when (and (buffer-file-name buf)   ; Ignore all non-file-visiting buffers.
                       (buffer-modified-p buf)) ; Ignore all unchanged buffers.
              (let ((buffer-save-without-query t))  ; Save silently.
                (save-buffer arg)))))))
    :bind (("C-x p" . project-switch-project)))
#+end_src

We can add a menu for project options as well
#+begin_src emacs-lisp
(pretty-hydra-define hydra-project
  (:hint nil :color teal :quit-key "q" :title (with-faicon "nf-fa-rocket" "Projectile" 1 -0.05))
  ("Buffers"
   (("b" project-switch-to-buffer "list")
    ("k" project-kill-buffers "kill all")
    ("S" smahm/project-save-all-buffers "save"))
   "Find"
   (("d" project-find-dir "directory")
    ("D" project-dired "root")
    ("f" project-find-file "file"))
   "Other"
   (("i" projectile-invalidate-cache "reset cache"))
   "Search"
   (("r" project-query-replace-regexp "regexp replace")
    ("s" consult-ripgrep "search"))))
  (global-set-key (kbd "C-c p") 'hydra-project/body)
#+end_src
* Editing
Typing or manipulating text is my primary purpose for using Emacs so let's improve on that.
** Defaults
Some sensible defaults for editing
#+begin_src emacs-lisp
  (setq-default
   fill-column 80                                   ; Set width for automatic line breaks
   tab-width 4                                      ; Set width for tabs
   kill-ring-max 128                                ; Maximum length of kill ring
   mark-ring-max 128                                ; Maximum length of mark ring
   kill-do-not-save-duplicates t                    ; Remove duplicates from kill ring
   require-final-newline t)                         ; Always add new line to end of file
  (delete-selection-mode t)                         ; Typing will replace a selected region
  (set-default-coding-systems 'utf-8)               ; Default to utf-8 encoding
  (prefer-coding-system 'utf-8)
  (set-language-environment 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
#+end_src
** Deletion
#+begin_src emacs-lisp
  (use-package simple
    :ensure nil
    :delight (auto-fill-function)
    :preface
    (defun smahm/kill-region-or-line ()
      "When called interactively with no active region, kill the whole line."
      (interactive)
      (if current-prefix-arg
          (progn
            (kill-new (buffer-string))
            (delete-region (point-min) (point-max)))
        (progn (if (use-region-p)
                   (kill-region (region-beginning) (region-end) t)
                 (kill-region (line-beginning-position) (line-beginning-position
                                                         2))))))
    (defun smahm/delete-surround-at-point-find-brackets (pos)
      "Return a pair of buffer positions for the opening & closing bracket positions.
  Or nil when nothing is found."
      (save-excursion
        (goto-char pos)
        (when
            (or
             (when
                 (and
                  (eq (syntax-class (syntax-after pos)) 4)
                  (= (logand (skip-syntax-backward "/\\") 1) 0))
               (forward-char 1)
               (if (and (ignore-errors (backward-up-list 1) t) (eq (point) pos))
                   t
                 (goto-char pos)
                 nil))
             (ignore-errors (backward-up-list 1) t))
          (list (point)
                (progn
                  (forward-list)
                  (1- (point)))))))
    (defun smahm/delete-surround-at-point ()
      "https://emacs.stackexchange.com/a/54679"
      (interactive)
      (let ((range (smahm/delete-surround-at-point-find-brackets (point))))
        (unless range
          (user-error "No surrounding brackets"))
        (pcase-let ((`(,beg ,end) range))
          (let ((lines (count-lines beg end))
                (beg-char (char-after beg))
                (end-char (char-after end)))
            (save-excursion
              (goto-char end)
              (delete-char 1)
              (goto-char beg)
              (delete-char 1))
            (message
             "Delete surrounding \"%c%c\"%s" beg-char end-char
             (if (> lines 1)
                 (format " across %d lines" lines)
               ""))))))
    :hook ((before-save . delete-trailing-whitespace)
           ((prog-mode text-mode) . turn-on-auto-fill))
    :bind (("C-M-d" . smahm/delete-surround-at-point)
           ([remap kill-region] . smahm/kill-region-or-line))
    :custom (set-mark-command-repeat-pop t))
#+end_src

Finally, I also like is to be able to delete every consecutive space characters
when a space character is deleted. The [[https://github.com/nflath/hungry-delete][hungry-delete]] package allows this
behavior.
#+begin_src emacs-lisp
  (use-package hungry-delete
    :defer 0.7
    :delight
    :config (global-hungry-delete-mode))
#+end_src
** Visual Clarity
[[https://github.com/paldepind/smart-comment][smart-comment]] allows for faster commenting and marking comments for deletion
#+begin_src emacs-lisp
(use-package smart-comment
  :bind ("M-;" . smart-comment))
#+end_src

Managing parentheses can be painful. One of the first things you want to do is
to change the appearance of the highlight of the parentheses pairs.
#+begin_src emacs-lisp
  (use-package faces
    :ensure nil
    :custom (show-paren-delay 0)
    :config
    (set-face-background 'show-paren-match "#161719")
    (set-face-bold 'show-paren-match t)
    (set-face-foreground 'show-paren-match "#ffffff"))
#+end_src

We can colour nested parentheses with the [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]] package.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :config
    (show-paren-mode 1))
#+end_src

We also want to match pairs properly
#+begin_src emacs-lisp
  (use-package smartparens
	:delight
	:hook ((minibuffer-setup-hook . turn-on-smartparens-strict-mode))
	:config
	(require 'smartparens-config)
	:bind (("C-M-b" . sp-backward-sexp)
		   ("C-M-f" . sp-forward-sexp)
		   ("M-(" . sp-wrap-round)
		   ("M-[" . sp-wrap-curly))
	:custom (sp-escape-quotes-after-insert nil))
#+end_src
** Navigation
Let's start with some useful functions that improve on existing Emacs navigation
#+begin_src emacs-lisp
  (use-package navigation
    :ensure nil
    :preface
    (defun smahm/smarter-move-beginning-of-line (arg)
      "Move point back to indentation of beginning of line."
      (interactive "^p")
      (setq arg (or arg 1))
      (when (/= arg 1)
        (let ((line-move-visual nil))
          (forward-line (1- arg))))
      (let ((orig-point (point)))
        (back-to-indentation)
        (when (= orig-point (point))
          (move-beginning-of-line 1))))
    (defun smahm/smart-kill-whole-line (&optional arg)
      "A simple wrapper around `kill-whole-line' that respects indentation."
      (interactive "P")
      (kill-whole-line arg)
      (back-to-indentation))
    (defun smahm/move-line-up ()
      "Move up the current line."
      (interactive)
      (transpose-lines 1)
      (forward-line -2)
      (indent-according-to-mode))
    (defun smahm/move-line-down ()
      "Move down the current line."
      (interactive)
      (forward-line 1)
      (transpose-lines 1)
      (forward-line -1)
      (indent-according-to-mode))
    (defun smahm/smart-open-line-below ()
      "Insert an empty line after the current line.
          Position the cursor at its beginning, according to the current mode."
      (interactive)
      (move-end-of-line nil)
      (newline-and-indent))
    (defun smahm/smart-open-line-above ()
      "Insert an empty line above the current line.
        Position the cursor at it's beginning, according to the current mode."
      (interactive)
      (move-beginning-of-line nil)
      (newline-and-indent)
      (forward-line -1)
      (indent-according-to-mode))
    (defun smahm/smart-kill-line-backwards ()
      "Insert an empty line above the current line.
        Position the cursor at it's beginning, according to the current mode."
      (interactive)
      (kill-line 0)
      (indent-according-to-mode))
    :bind (("M-p" . smahm/move-line-up)
           ("M-n" . smahm/move-line-down)
           ("C-a" . smahm/smarter-move-beginning-of-line)
           ("C-<return>" . smahm/smart-open-line-below)
           ("M-<return>" . smahm/smart-open-line-above)
           ("M-<backspace>" . smahm/smart-kill-line-backwards)
           ([remap kill-whole-line] . smahm/smart-kill-whole-line)))
#+end_src

back-button
#+begin_src emacs-lisp
  (use-package back-button
    :bind (("C-M-<" . back-button-global-backward)
           ("C-M->" . back-button-global-forward)
           ("C-<" . back-button-local-backward)
           ("C->" . back-button-local-forward)))
#+end_src

[[https://github.com/abo-abo/avy][Avy]] is an amazing package that allows one to go truly mouseless and navigate via links
#+begin_src emacs-lisp
  (use-package avy
    :config
    (defun avy-action-embark (pt)
      (unwind-protect
          (save-excursion
            (goto-char pt)
            (embark-act))
        (select-window
         (cdr (ring-ref avy-ring 0))))
      t)
    (setf (alist-get ?. avy-dispatch-alist) 'avy-action-embark)
    :bind
    ("C-s a" . avy-goto-char-timer))
#+end_src

** Search and Replace
[[https://github.com/szermatt/visual-replace][visual-replace]] shows your replace changes live as you type which is neat.
#+begin_src emacs-lisp
  (use-package visual-replace
    :config
    (define-key visual-replace-mode-map (kbd "M-%")
                visual-replace-secondary-mode-map)
    :bind (([remap query-replace] . visual-replace)
           :map isearch-mode-map
           ("M-%" . visual-replace-from-isearch)))
#+end_src
** Linguistics
[[https://github.com/minad/jinx][Jinx]] powered by libenchant seems to be the best spell checker today
#+begin_src emacs-lisp
  (use-package jinx
    :bind ([remap ispell-word] . jinx-correct))
#+end_src

Occasionally, I would like to have a summary of a term directly on GNU Emacs,
before that I would like to know more about this term. The [[https://github.com/jozefg/wiki-summary.el][wiki-summary]] package
allows this behaviour.
#+begin_src emacs-lisp
  (use-package wiki-summary
	:commands (wiki-summary wiki-summary-insert)
	:preface
	(defun smahm/format-summary-in-buffer (summary)
	  "Given a summary, sticks it in the *wiki-summary* buffer and displays
	   the buffer."
	  (let ((buf (generate-new-buffer "*wiki-summary*")))
		(with-current-buffer buf
		  (princ summary buf)
		  (fill-paragraph)
		  (goto-char (point-min))
		  (view-mode))
		(pop-to-buffer buf)))
	:config
	(advice-add 'wiki-summary/format-summary-in-buffer
				:override #'smahm/format-summary-in-buffer))
#+end_src

This function saves me time to find the definition of a word
#+begin_src emacs-lisp
  (defun google-current-word ()
  "Search the current word on Google using browse-url."
  (interactive)
  (let ((word (thing-at-point 'word)))
    (if word
        (browse-url (concat "https://www.google.com/search?q=" word))
      (message "No word found at point."))))
#+end_src

We can add a menu for language options as well
#+begin_src emacs-lisp
  (pretty-hydra-define hydra-lang
    (:hint nil :color teal :quit-key "q" :title (with-faicon "nf-fa-magic" "Spelling" 1 -0.05))
    ("Spell Check"
     (("<" jinx-previous "previous" :color pink)
      (">" jinx-next "next" :color pink)
      ("w" jinx-correct-word "word")
      ("a" jinx-correct-all "all")
      ("m" jinx-mode "mode" :toggle t))
     "Lanaguage"
     (("g" google-current-word "google")
      ("l" jinx-languages "language")
      ("s" wiki-summary "wiki"))
     "Word"
     (("u" upcase-dwim "upcase")
      ("d" downcase-dwim "downcase")
      ("c" capitalize-dwim "capitalize"))))
  (global-set-key (kbd "C-c j") 'hydra-lang/body)
#+end_src
** Multi-Edit
[[https://github.com/magnars/multiple-cursors.el][multiple-cursors]] is a package that allows you to edit multiple lines at once and is really nifty once you kinda get the hang of it.
#+begin_src emacs-lisp
  (use-package multiple-cursors
    :bind (("C-c m r" . mc/mark-all-in-region-regexp)
  		 ("C-c m b" . mc/edit-beginnings-of-lines)
  		 ("C-c m e" . mc/edit-ends-of-lines)))
#+end_src
** Undo/Redo
[[https://github.com/casouri/vundo][Vundo]] is a really cool package that show your undo history and allows you traverse this tree
#+begin_src emacs-lisp
  (use-package vundo
    :config
    (setq vundo-glyph-alist vundo-ascii-symbols)
    :bind (("C-x u" . vundo)))
#+end_src

[[https://github.com/emacsmirror/undo-fu][undo-fu]] allows us to incerase our undo history
#+begin_src emacs-lisp
    (use-package undo-fu
      :bind (:map global-map
                  ("C-/" . undo-fu-only-undo)
                  ("C-?" . undo-fu-only-redo))
      :config
      (setq undo-limit 67108864) ; 64mb.
      (setq undo-strong-limit 100663296) ; 96mb.
      (setq undo-outer-limit 1006632960)) ; 960mb
#+end_src

[[https://github.com/emacsmirror/undo-fu-session][undo-fu-session]] saves your undo history between sessions
#+begin_src emacs-lisp
  (use-package undo-fu-session
    :init
    (undo-fu-session-global-mode 1)
    :custom
    (undo-fu-session-directory (expand-file-name (format "%s/emacs/undo-fu-session" xdg-cache))))
#+end_src
** Sudo
The following package re-opens a file with sudo rights
#+begin_src emacs-lisp
(use-package sudo-edit)
#+end_src
* Development
** Tree-sitter
Tree-sitter (as far as my understanding goes) is basically the LSP of languages but for syntax. It replaces all the different "x-language-mode" to a common one which aims to provide all the benefits such as code highlighting and structural editing.

Currently though there is no clean way to implement tree-sitter for all languages so this package helps to alleviate some of those paint points.
#+begin_src emacs-lisp
  ;; (use-package treesit-auto
  ;;   :custom
  ;;   (treesit-auto-install 'prompt)
  ;;   :config
  ;;   (setq treesit-auto-langs '(python go))
  ;;   (global-treesit-auto-mode))
#+end_src
** Version Control
No surprises here magit is my proffered git interface
#+begin_src emacs-lisp
  (use-package magit
    :bind (("C-x g" . magit-status)))
#+end_src

To make sure that the summary and the body of the commits respect the
conventions, the [[https://github.com/magit/magit/blob/master/lisp/git-commit.el][git-commit]] package from magit is perfect.
#+begin_src emacs-lisp
  (use-package git-commit
    :ensure nil
    :preface
    (defun smahm/git-commit-auto-fill-everywhere ()
      "Ensure that the commit body does not exceed 72 characters."
      (setq fill-column 72)
      (setq-local comment-auto-fill-only-comments nil))
    :hook (git-commit-mode . smahm/git-commit-auto-fill-everywhere)
    :custom (git-commit-summary-max-length 50))
#+end_src

I like to know the modified lines of a file while I edit it.
#+begin_src emacs-lisp
  (use-package git-gutter
    :defer 0.3
    :delight
    :config (global-git-gutter-mode))
#+end_src

Finally, some quality of life functions
#+begin_src emacs-lisp
  (defun smahm/open-on-github ()
    "Open current file in github"
    (interactive)
    (let
        ((repo-url (magit-git-string "remote" "get-url" "--push" "origin"))
         (commit-hash (magit-git-string "rev-parse" "HEAD"))
         (start-line (if (use-region-p)
                         (line-number-at-pos (region-beginning))
                       (line-number-at-pos)))
         (end-line (if (use-region-p) (line-number-at-pos (region-end)))))
      (unless repo-url (error  "not in a git repo"))
      (browse-url
       (concat
        (substring repo-url 0 -4)
        "/blob/"
        commit-hash
        "/"
        (substring buffer-file-name (length (projectile-project-root)))
        "#L" (number-to-string start-line)
        (if (and (use-region-p) (< 0 (- end-line start-line)))
            (concat "..L" (number-to-string end-line)))
        ))))
#+end_src

We can add a menu for git options as well
#+begin_src emacs-lisp
    (pretty-hydra-define hydra-magit
  	(:hint nil :color teal :quit-key "q" :title (with-octicon "nf-oct-mark_github" "Magit" 1 -0.05))
  	("Action"
  	 (("g" smahm/open-on-github "open")
  	  ("b" magit-blame "blame")
  	  ("c" magit-clone "clone")
  	  ("i" magit-init "init")
  	  ("l" magit-log-buffer-file "commit log (current file)")
  	  ("L" magit-log-current "commit log (project)")
  	  ("s" magit-status "status"))))
    (global-set-key (kbd "C-c g") 'hydra-magit/body)
#+end_src
** Language Server
Emacs has a lot of great LSP clients namely eglot, lsp-mode and lsp-bridge. Eglot is my choice currently as it is built-in to emacs (29+) and also seems to be the more minimalist option.
#+begin_src emacs-lisp
  (use-package eglot
    :custom
    (fset #'jsonrpc--log-event #'ignore)
    (eglot-events-buffer-size 0)
    (eglot-sync-connect nil)
    (eglot-connect-timeout nil)
    (eglot-autoshutdown t)
    (eglot-send-changes-idle-time 3)
    (flymake-no-changes-timeout 5)
    (eldoc-echo-area-use-multiline-p nil)
    (setq eglot-ignored-server-capabilities '( :documentHighlightProvider)))
  (use-package eglot-booster
    :after eglot
    :vc (:url "https://github.com/jdtsmith/eglot-booster" :branch "main")
    :config
    (eglot-booster-mode))
#+end_src
** Linters/Documentation
Eldoc shows function arguments in the echo area
#+begin_src emacs-lisp
  (use-package eldoc
    :after eglot
    :ensure nil
    :config
    (eldoc-add-command 'smahm/escape)
    (with-eval-after-load 'eglot
      (add-hook 'eglot-managed-mode-hook
                (lambda ()
                  ;; Show flymake diagnostics first.
                  (setq eldoc-documentation-functions
                        (cons #'flymake-eldoc-function
                              (remove #'flymake-eldoc-function eldoc-documentation-functions)))
                  ;; Show all eldoc feedback.
                  (setq eldoc-documentation-strategy #'eldoc-documentation-compose)))))
#+end_src
Eglot has built-in support for flymake so that is what we will use as our syntax
checker
#+begin_src emacs-lisp
  (use-package flymake
    :ensure nil
    :config
    (custom-set-variables
     '(help-at-pt-timer-delay 1)
     '(help-at-pt-display-when-idle '(flymake-overlay))))
#+end_src
And a menu for flymake
Eglot has built-in support for flymake so that is what we will use as our syntax
checker
#+begin_src emacs-lisp
  (pretty-hydra-define hydra-flymake
    (:hint nil :color teal :quit-key "q" :title (with-faicon "nf-fa-plane" "Flymake" 1 -0.05))
    ("Checker"
     (("s" flymake-start "syntax")
      ("m" flymake-mode "mode" :toggle t))
     "Errors"
     (("<" flymake-goto-prev-error "previous" :color pink)
      (">" flymake-goto-next-error "next" :color pink)
      ("b" flymake-show-buffer-diagnostics "buffer")
      ("p" flymake-show-project-diagnostics "project")
      ("l" flymake-switch-to-log-buffer "log"))
     "Other"
     (("c" consult-flymake "consult"))))
  (global-set-key (kbd "C-c e") 'hydra-flymake/body)
#+end_src
** Snippets
Yasnippet is the most popular snippet package but I wanted a more minmalistic package and tempel seems to be just that
#+begin_src emacs-lisp
  (use-package tempel
    :commands (tempel-expand)
    :bind (("M-+" . tempel-expand)
           ("M-*" . tempel-insert)
           (:map tempel-map (("C-n" . tempel-next)
                             ("C-p" . tempel-previous))))
    :config
    (setq-default tempel-path (expand-file-name (format "%s/snippets/*.eld" user-emacs-directory))))
#+end_src
These are some snippets available globally
#+begin_src lisp-data :tangle snippets/fundamental.eld :mkdirp yes
  fundamental-mode
  (today (format-time-string "%Y-%m-%d"))
  (NOW (format-time-string "%Y-%m-%d %a %H:%M"))
  (yesterday (format-time-string "%Y-%m-%d" (time-subtract nil (* 24 60 60))))
  (tomorrow (format-time-string "%Y-%m-%d" (time-add nil (* 24 60 60))))
#+end_src
** Virtualization
I use docker quite extensively so the following package is a staple for me
#+begin_src emacs-lisp
(use-package docker)
#+end_src
* Org
Org short for organization of my life mainly by using org-mode
** Defaults
Org Mode is a really good package for note taking and organization.
#+begin_src emacs-lisp
  (use-package org
    :ensure nil
    :mode (("\\.org\\'" . org-mode))
    :bind (:map org-mode-map
                ("C-M-p" . org-shiftmetaleft)
                ("C-M-n" . org-shiftmetaright)
                ("M-<return>" . org-meta-return))
    :hook
    (org-mode . org-indent-mode)
    (org-mode . visual-line-mode)
    (org-mode . jinx-mode)
    :custom
    (org-directory "~/org")
    (org-archive-location "~/org/archives/%s::")
    (org-confirm-babel-evaluate nil)
    (org-log-done 'time)
    (org-return-follows-link t)
    (org-hide-emphasis-markers t)
    :config
    (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode)))
  (use-package org-contrib)
#+end_src

If like me you want to automatically update the tables of contents of your org
files, [[https://github.com/snosov1/toc-org][toc-org]] is the ideal package. To automate these tables of contents, you
only need to use the =:TOC:= tag in the first heading of these tables of contents.
#+begin_src emacs-lisp
  (use-package toc-org
    :after org
    :hook (org-mode . toc-org-enable))
#+end_src

We can add a menu for org options as well
#+begin_src emacs-lisp
  (pretty-hydra-define hydra-org
    (:hint nil :color teal :quit-key "q" :title (with-faicon "nf-fa-pen" "Org" 1 -0.05))
    ("Action"
     (("A" smahm/org-archive-done-tasks "archive")
      ("a" org-agenda "agenda")
      ("c" org-capture "capture")
      ("l" smahm/org-open-current-ledger "ledger")
      ("d" org-decrypt-entry "decrypt")
      ("i" org-insert-link-global "insert-link")
      ("j" org-capture-goto-last-stored "jump-capture")
      ("k" org-cut-subtree "cut-subtree")
      ("o" org-open-at-point-global "open-link")
      ("r" org-refile "refile")
      ("s" org-store-link "store-link")
      ("t" org-show-todo-tree "todo-tree"))))
  (global-set-key (kbd "C-c o") 'hydra-org/body)
#+end_src
** Faces
Let's add prettier bullets in Org Mode with [[https://github.com/integral-dw/org-superstar-mode][org-superstar]].
#+begin_src emacs-lisp
  (use-package org-faces
    :ensure nil
    :custom
    (org-todo-keyword-faces
      (quote (("TODO" :foreground "red" :weight bold)
              ("NEXT" :foreground "blue" :weight bold)
              ("DONE" :foreground "forest green" :weight bold)
              ("WAITING" :foreground "orange" :weight bold)
              ("LATER" :foreground "magenta" :weight bold)
              ("NOPE" :foreground "grey" :weight bold)))))
#+end_src

Let's add prettier bullets in Org Mode with [[https://github.com/integral-dw/org-superstar-mode][org-superstar]].
#+begin_src emacs-lisp
  (use-package org-superstar
    :hook
    (org-mode . org-superstar-mode)
    :config
    (dolist (face '((org-level-1 . 1.35)
                    (org-level-2 . 1.3)
                    (org-level-3 . 1.2)
                    (org-level-4 . 1.1)
                    (org-level-5 . 1.1)
                    (org-level-6 . 1.1)
                    (org-level-7 . 1.1)
                    (org-level-8 . 1.1))))
    (setq org-superstar-remove-leading-stars t)
    (setq org-superstar-headline-bullets-list '("☰" "☷" "☵" "☲"  "☳" "☴"  "☶"  "☱" )))
#+end_src
** Agenda
Nowadays, it is crucial to be organized. Even more than before. That is why it
is important to take the time to make a configuration that is simple to use and
that makes your life easier. The org-agenda
built-in package allows me to be organized in my daily tasks. As a result, I can
use my time to the fullest.
#+begin_src emacs-lisp
  (use-package org-agenda
    :ensure nil
    :bind (:map org-agenda-mode-map
                ("C-n" . org-agenda-next-item)
                ("C-p" . org-agenda-previous-item)
                ("j" . org-agenda-goto)
                ("X" . smahm/org-agenda-mark-done-next)
                ("x" . smahm/org-agenda-mark-done))
    :custom
    (org-agenda-files '("~/org/todos")))
#+end_src
** Capture
Org-capture templates saves you a lot of time when adding new entries. I use
it to quickly record tasks, ledger entries, notes and other semi-structured
information.
#+begin_src emacs-lisp
  (use-package org-capture
    :ensure nil
    :custom
    (org-todo-keywords
     (quote ((sequence "TODO(t)""|" "NEXT(n)""|" "DONE(d)")
             (sequence "WAITING(w@/!)" "LATER(l@/!)""|" "NOPE(x@/!)"))))
    (org-capture-templates
     `(("p" "Personal To-Do"
        entry (file+headline "~/org/todos/personal.org" "General Tasks")
        "* TODO [#B] %?\n:Created: %T\n "
        :empty-lines 0))))
#+end_src
** Note Taking
#+begin_src emacs-lisp
  (use-package org-roam
    :custom
    (org-roam-directory (file-truename "~/org/notes"))
    :config
    ;; If you're using a vertical completion framework, you might want a more informative completion interface
    (setq org-roam-node-display-template (concat "${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
    (org-roam-db-autosync-mode))
#+end_src

And a menu for org-roam
#+begin_src emacs-lisp
(pretty-hydra-define hydra-notes
  (:hint nil :color teal :quit-key "q" :title (with-octicon "nf-oct-pencil" "Notes" 1 -0.05))
  ("Notes"
   (("c" org-roam-dailies-capture-today "capture")
    ("C" org-roam-dailies-capture-tomorrow "capture tomorrow")
    ("g" org-roam-graph "graph")
    ("f" org-roam-node-find "find")
    ("i" org-roam-node-insert "insert"))
   "Go To"
   ((">" org-roam-dailies-goto-next-note "next note")
    ("<" org-roam-dailies-goto-previous-note "previous note")
    ("d" org-roam-dailies-goto-date "date")
    ("t" org-roam-dailies-goto-today "today")
    ("T" org-roam-dailies-goto-tomorrow "tomorrow")
    ("y" org-roam-dailies-goto-yesterday "yesterday"))))
(global-set-key (kbd "C-c n") 'hydra-notes/body)
#+end_src

** Time Management
#+begin_src emacs-lisp
#+end_src
** Money Management
Good money management is a skill to be acquired as soon as possible. Fortunately
for us, [[https://www.ledger-cli.org/][Ledger]] allows you to have a double-entry accounting system directly from
the UNIX command line. To use Ledger with GNU Emacs, you need to the [[https://github.com/ledger/ledger-mode][ledger-mode]]
package.
#+begin_src emacs-lisp
(use-package ledger-mode
    :mode ("\\.\\(dat\\|ledger\\)\\'")
    :preface
    (defun smahm/ledger-save ()
      "Clean the ledger buffer at each save."
      (interactive)
      (ledger-mode-clean-buffer)
      (save-buffer))
    :bind (:map ledger-mode-map
                ("C-x C-s" . smahm/ledger-save))
    :hook (ledger-mode . ledger-flymake-enable)
    :custom
    (ledger-clear-whole-transactions t))
#+end_src

Org (7.01+) has built-in support for ledger entries using Babel.
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((ledger . t)))
#+end_src

We can also define a function to open the current years ledger file
#+begin_src emacs-lisp
  (defun smahm/org-open-current-ledger ()
    "Open the ledger file corresponding to the current year."
    (interactive)
    (let* ((current-year (format-time-string "%Y"))
           (ledger-file (format "~/org/ledger/%s.org.gpg" current-year)))
      (find-file ledger-file)))
#+end_src
* Languages
** Defaults
Sensible default programming modes that I use.
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook #'corfu-mode)
  (add-hook 'prog-mode-hook #'display-line-numbers-mode)
  (add-hook 'prog-mode-hook #'eldoc-mode)
  (add-hook 'prog-mode-hook #'flymake-mode)
  (add-hook 'prog-mode-hook #'smartparens-mode)
  (add-hook 'prog-mode-hook #'jinx-mode)
  (add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
  (remove-hook 'prog-mode-hook 'turn-on-auto-fill)
#+end_src
** Yaml
Yaml development environment.
*** Config
#+begin_src emacs-lisp
  (use-package yaml-mode
    :mode (("\\.yml\\'" . yaml-ts-mode)
           ("\\.yaml\\'" . yaml-ts-mode))
    :hook
    (yaml-mode . yaml-pro-mode)
    :init
    (add-to-list 'eglot-server-programs '((yaml-ts-mode) . ("yaml-language-server" "start")))
    :preface
    (defun smahm/yaml-format ()
      "Compile current buffer file with yaml."
      (interactive)
      (compile (format "yamlfmt %s" buffer-file-name)))
    (defun smahm/yaml-check ()
      "Compile current buffer file with yaml."
      (interactive)
      (compile (format "yamllint %s" buffer-file-name))))
#+end_src
*** Snippets
Yaml specific snippets for tempel
#+begin_src emacs-lisp
#+end_src
*** Menu
We can add a menu for python specific functions
#+begin_src emacs-lisp
  (pretty-hydra-define hydra-yaml
    (:hint nil :forein-keys warn :quit-key "q" :title (with-octicon "nf-oct-terminal" "yaml" 1 -0.05))
    ("Format"
     (("f" smahm/yaml-format "format")
      ("c" smahm/yaml-check "check"))))
  (with-eval-after-load "yaml-mode"
    (define-key yaml-ts-mode-map (kbd "C-c r") 'hydra-yaml/body))
#+end_src

** Python
Python development environment.
*** Config
#+begin_src emacs-lisp
  (use-package python
    :ensure nil
    :mode (("\\.py\\'" . python-ts-mode))
    :interpreter ("python" . python-ts-mode)
    :hook
    (python-ts-mode . eglot-ensure)
    :init
    (add-to-list 'eglot-server-programs '((python-ts-mode) . ("pyright-langserver" "--stdio")))
    :preface
    (defun smahm/pyrightconfig-write (virtualenv)
      "From https://robbmann.io/posts/emacs-eglot-pyrightconfig/
       Write a `pyrightconfig.json' file at the Git root of a project
       with `venvPath' and `venv' set to the absolute path of
       `virtualenv'.  When run interactively, prompts for a directory to
       select."
      (interactive "DEnv: ")
      ;; Naming convention for venvPath matches the field for pyrightconfig.json
      (let* ((venv-dir (tramp-file-local-name (file-truename virtualenv)))
             (venv-file-name (directory-file-name venv-dir))
             (venvPath (file-name-directory venv-file-name))
             (venv (file-name-base venv-file-name))
             (base-dir (vc-git-root default-directory))
             (out-file (expand-file-name "pyrightconfig.json" base-dir))
             (out-contents (json-encode (list :venvPath venvPath :venv venv))))
        (with-temp-file out-file (insert out-contents))
        (message (concat "Configured `" out-file "` to use environment `" venv-dir))))
    (defun smahm/python-venv-setup ()
      "Install .pyvenv virtual environment at the root of the project.
  Additionally installed libraries from requirements.txt if it exists."
      (interactive)
      (let* ((base-dir (vc-git-root default-directory)) (venv-dir (concat base-dir ".venv")))
        (progn
          (save-window-excursion
            (shell-command (s-concat "python3 -m venv " venv-dir))
            (when (file-exists-p (concat base-dir "requirements.txt"))
              (shell-command (s-concat "source " venv-dir "/bin/activate && pip3 install -r " base-dir "requirements.txt")))
            (smahm/pyrightconfig-write venv-dir)))
        (message (concat "Created " venv-dir))))
    (defun smahm/python-run ()
      "Compile current buffer file with python."
      (interactive)
      (compile (format "python3 %s" buffer-file-name)))
    (defun smahm/python-format ()
      "Compile current buffer file with python."
      (interactive)
      (compile (format "ruff format %s" buffer-file-name))
      (smahm/revert-buffer-no-confirm))
    (defun smahm/python-check ()
      "Compile current buffer file with python."
      (interactive)
      (compile (format "ruff check %s" buffer-file-name)))
    :config
    ;; Error message support for pyright in a *Compilation* buffer
    (with-eval-after-load 'compile
      (add-to-list 'compilation-error-regexp-alist-alist
                   '(pyright "^[[:blank:]]+\\(.+\\):\\([0-9]+\\):\\([0-9]+\\).*$" 1 2 3))
      (add-to-list 'compilation-error-regexp-alist 'pyright))
    (setq python-check-command "NO_COLOR=1 ruff check"))
#+end_src
*** Snippets
Python specific snippets for tempel
#+begin_src lisp-data :tangle snippets/python.eld :mkdirp yes
python-ts-mode python-ts-mode
(__contains__ "def __contains__(self, el):" n> p n> "pass")
(__enternn__ "def __enter__(self):" n> p n> "return self")
(__eq__ "def __eq__(self, other):" n> "return self." p " == other." q)
(__exit__ "def __exit__(self, type, value, traceback):" n> p n> "pass")
(__getitem__ "def __len__(self):" n> p n> "pass")
(__iter__ "def __iter__(self):" n> "return " q)
(__new__ "def __new__(mcs, name, bases, dict):" n> p n> "return type.__new__(mcs, name, bases, dict)")
(__setitem__ "__all__ = [" n> p n> "]")
(arg "parser.add_argument('-" p "', '--" p "'," n> p ")")
(arg_positional "parser.add_argument('" p "', " p ")")
(assert "assert " q)
(assertEqual "self.assertEqual(" p ", " p ")")
(assertFalse "self.assertFalse(" p ")")
(assertIn "self.assertIn(" p ", " p ")")
(assertNotEqual "self.assertNotEqual(" p ", " p ")")
(assertRaises "assertRaises(" p ", " p ")")
(assertRaises-with "with self.assertRaises(" p "):" n> q)
(assertTrue "self.assertTrue(" p ")")
(celery_pdb "from celery.contrib import rdb; rdb.set_trace()")
(class "class " p":" n> "def __init__(self" p "):" n> q)
(classmethod "@classmethod" n> "def " p "(cls, " p "):" n> q)
(def_decorator "def " p "(func):" n> p n> "def _" p "(*args, **kwargs):" n> p n> "ret = func(*args, **kwargs)" n> p n> "return ret" n n> "return _" q)
(def_function "def " p "(" p "):" n> q)
(doc "\"\"\"" p "\"\"\"")
(doctest ">>> " p n> q)
(for "for " p " in " p ":" n> q)
(from "from " p " import " q)
(function_docstring "def " p "(" p "):" n> "\"\"\"" p "\"\"\"" n> q)
(if "if " p ":" n> q)
(ife "if " p ":" n> p n> "else:" n> q)
(ifmain "if __name__ == '__main__':" n> q)
(ig "# type: ignore" q)
(imp "import " q)
(fimp "from " p " import " q)
(init "def __init__(self" p "):" n> q)
(init_docstring "def __init__(self" p "):" n> "\"\"\"" p "\"\"\"" n> q)
(interact "import code; code.interact(local=locals())")
(ipdb_trace "import ipdb; ipdb.set_trace()")
(lambda "lambda " p ": " q)
(list "[" p " for " p " in " p "]")
(logger_name "logger = logging.getLogger(__name__)")
(logging "logger = logging.getLogger(\"" p "\")" n> "logger.setLevel(logging." p ")")
(main "def main():" n> q)
(metaclass "__metaclass__ = type")
(method "def " p "(self" p "):" n> q)
(method_docstring "def " p "(self" p "):" n> "\"\"\"" p "\"\"\"" n> q)
(not_impl "raise NotImplementedError")
(np "import numpy as np" n> q)
(parse_args "def parse_arguments():" n> "parser = argparse.ArgumentParser(description='" p "')" n> p n> "return parser.parse_args()")
(pd "import pandas as pd" n> q)
(tf "import tensorflow as tf" n> q)
(tr & "import " p "; " p ".set_trace()" q)
(parser "parser = argparse.ArgumentParser(description='" p "')" n> q)
(pass "pass")
(p "print(\"" p "\")")
(pf "print(f\"" p "\")")
(prop "def " p "():"
      n> "doc = \"\"\"" p "\"\"\""
      n> "def fget(self):"
      n> "return self._" p
      n> n> "def fset(self, value):"
      n> "self._" p " = value"
      n> n> "def fdel(self):"
      n> "del self._" p
      n> "return locals()"
      n> p " = property(**" p "())")
(reg p " = re.compile(r\"" p "\")")
(__repr__ "def __repr__(self):" n> q)
(return "return " q)
(script "#!/usr/bin/env python" n n> "def main():" n> "pass" n n> "if __name__ == '__main__':" n> "main()")
(self "self." q)
(self_without_dot "self")
(selfassign "self." p " = " q)
(setdef p ".setdefault(" p ", []).append(" p ")")
(setup "from setuptools import setup" n n> "package = '" p "'" n> "version = '" p "'" n n> "setup(name=package," n> "version=version," n> "description=\"" p "\"," n> "url='" p "'" p ")")
(shebang_line "#!/usr/bin/env python" n> q)
(size "sys.getsizeof(" p ")")
(static "@staticmethod" n> "def " p "(" p "):" n> q)
(__str__ "def __str__(self):" n> q)
(super "super(" p ", self)." p "(" p ")")
(test_class "class Test" p "(" p "):" n> q)
(test_file "import unittest" n> "from " p " import *" n> p n> "if __name__ == '__main__':" n> "unittest.main()")
(trace "import pdb; pdb.set_trace()")
(try "try:" n> p n> "except " p ":" n> q)
(tryelse "try:" n> p n> "except " p ":" n> p n> "else:" n> q)
(__unicode__ "def __unicode__(self):" n> q)
(utf-8_encoding "# -*- coding: utf-8 -*-")
(while "while " p ":" n> q)
(with "with " p p ":" n> q)
(with_statement "from __future__ import with_statement")
#+end_src
*** Menu
We can add a menu for python specific functions
#+begin_src emacs-lisp
  (pretty-hydra-define hydra-python
	(:hint nil :forein-keys warn :quit-key "q" :title (with-faicon "nf-fa-python" "Python" 1 -0.05))
	("Venv"
	 (("v" smahm/pyrightconfig-write "set venv")
	  ("V" smahm/python-venv-setup "create venv"))
	 "Run"
	 (("r" smahm/python-run "run"))
	 "Format"
	 (("f" smahm/python-format "format")
	  ("c" smahm/python-check "check"))))
  (with-eval-after-load "python"
	(define-key python-ts-mode-map (kbd "C-c r") 'hydra-python/body))
#+end_src
** C/C++
C/C++ development environment.
*** Config
#+begin_src emacs-lisp
  (use-package c
    :ensure nil
    :mode (("\\.c" . c-mode))
    :interpreter ("c" . c-mode)
    :hook
    (c-mode . eglot-ensure)
    :init
    (add-to-list 'eglot-server-programs '((c-mode c-mode) . ("clangd" "-j=8" "--log=error" "--malloc-trim" "--background-index" "--clang-tidy" "--all-scopes-completion" "--completion-style=detailed" "--pch-storage=memory" "--header-insertion=never" "--header-insertion-decorators=0")))
    :preface
    (defun smahm/c-run ()
      "Compile current buffer file with c."
      (interactive)
      (compile (format "clang -Wall %s -o %s.out && %s.out" buffer-file-name buffer-file-name buffer-file-name)))
    (defun smahm/c-cpp-format ()
      "Compile current buffer file with c."
      (interactive)
      (compile (format "clang-format %s" buffer-file-name)))
    (defun smahm/c-cpp-check ()
      "Compile current buffer file with c."
      (interactive)
      (compile (format "clang-check %s" buffer-file-name))))
#+end_src
#+begin_src emacs-lisp
    (use-package c++
      :ensure nil
      :mode (("\\.cc\\'" . c++-ts-mode)
             ("\\.cpp\\'" . c++-ts-mode))
      :interpreter ("c++" . c++-ts-mode)
      :hook
      (c++-ts-mode . eglot-ensure)
      :init
      (add-to-list 'eglot-server-programs '((c++-mode cc-mode c++-ts-mode) . ("clangd" "-j=8" "--log=error" "--malloc-trim" "--background-index" "--clang-tidy" "--all-scopes-completion" "--completion-style=detailed" "--pch-storage=memory" "--header-insertion=never" "--header-insertion-decorators=0")))
      :preface
      (defun smahm/c-run ()
        "Compile current buffer file with c."
        (interactive)
        (compile (format "clang++ -Wall %s -o %s.out && %s.out" buffer-file-name buffer-file-name buffer-file-name)))
      (defun smahm/c-cpp-format ()
        "Compile current buffer file with c."
        (interactive)
        (compile (format "clang-format -style=Google -i %s" buffer-file-name))
        (smahm/revert-buffer-no-confirm))
      (defun smahm/c-cpp-check ()
        "Compile current buffer file with c."
        (interactive)
        (compile (format "clang-check --analyze %s" buffer-file-name))))
#+end_src
*** Snippets
C specific snippets for tempel
#+begin_src lisp-data :tangle snippets/c.eld :mkdirp yes
#+end_src
*** Menu
We can add a menu for c and c++ specific functions
#+begin_src emacs-lisp
  (pretty-hydra-define hydra-c-cpp
	(:hint nil :forein-keys warn :quit-key "q" :title (with-mdicon "nf-md-language_c" "C/C++" 1 -0.05))
	("Run"
	 (("r" smahm/c-run "run"))
	 "Format"
	 (("f" smahm/c-cpp-format "format")
	  ("c" smahm/c-cpp-check "check"))))
  (with-eval-after-load "c-mode"
	(define-key c-mode-map (kbd "C-c r") 'hydra-c-cpp/body))
  (with-eval-after-load "c-mode"
	(define-key c++-ts-mode-map (kbd "C-c r") 'hydra-c-cpp/body))
#+end_src
** Go
Golang development environment.
*** Config
#+begin_src emacs-lisp
  (use-package go
    :ensure nil
    :mode ("\\.go\\'" . go-ts-mode)
    :interpreter ("go" . go-ts-mode)
    :hook
    (go-ts-mode . eglot-ensure)
    :preface
    (defun smahm/go-run ()
      "Compile current buffer file with go."
      (interactive)
      (compile (format "go run %s" buffer-file-name)))
    (defun smahm/go-format ()
      "Format current buffer file with goimports."
      (interactive)
      (compile (format "goimports -w %s && gofumpt -w %s" buffer-file-name buffer-file-name))
      (smahm/revert-buffer-no-confirm))
    (defun smahm/go-check ()
      "Check current buffer file with goimports."
      (interactive)
      (compile (format "gofumpt -e %s" buffer-file-name)))
    :config
    (add-hook 'go-ts-mode-hook
              (lambda ()
                (setq-local eglot-workspace-configuration
                            '((:gopls .
                                      ((staticcheck . t)
                                       (matcher . "CaseSensitive"))))))))
#+end_src
*** Snippets
Go specific snippets for tempel
#+begin_src lisp-data :tangle snippets/go.eld :mkdirp yes
go-ts-mode go-ts-mode
(imp "import " q)
(impn "import (" n> q n ")")
(pr "fmt.Printf(\"\\n" p "\\n%#v\\n\", " q ")")
(pl "fmt.Println(" q ")")
(db "Debug.Printf(\"\\n" p "\\n\\n%#v\\n\", " q ")")
(dl "Debug.Println(" q ")")
(lf "log.Printf(\"\\n%#v\\n\", " q ")")
(ln "log.Println(" q ")")
(stt "type " p " struct {" n> q n "}")
(inf "type " p " interface {" n> q n "}")
(cnt "const " p " = " q )
(cnst "const (" n> p " = " q n ")")
(vr "var " p " " q)
(mp "map[" p "]" q)
(if "if " p " {" n> p n "}" > q)
(el "if " p " {" n> p n "} else {" > n> p n "}" > q)
(elif "if " p " {" n> p n "} else if " > p " {" n> p n "}" > q)
(ifen "if err != nil {" n> q n "}" >)
(ifer "if err != " p " {" n> q n "}" >)
(sel "select {" n> "case " p ":" n> q n "}" >)
(swch "switch " p " {" n> "case " p ":" q n "}" >)
(fr "for " p "{" n> q n "}" >)
(rng "for " p ", " p " := range " p " {" n> q n "}" >)
(fnc "func " p "(" p ") {" n> q n "}" >)
(mn "func main() {" n> q n "}")
(in "func init() {" n> q n "}")
(tst "func Test" p " (t *testing.T) { " n> q n "}")
#+end_src
*** Menu
We can add a menu for python specific functions
#+begin_src emacs-lisp
  (pretty-hydra-define hydra-go
	(:hint nil :forein-keys warn :quit-key "q" :title (with-mdicon "nf-md-language_go" "Go" 1 -0.05))
	("Run"
	 (("r" smahm/go-run "run"))
	 "Format"
	 (("f" smahm/go-format "format")
	  ("c" smahm/go-check "check"))))
  (with-eval-after-load "go-ts-mode"
	(define-key go-ts-mode-map (kbd "C-c r") 'hydra-go/body))
#+end_src
** Rust
Rust development environment.
*** Config
#+begin_src emacs-lisp
  (use-package rust
    :ensure nil
    :commands rust-ts-mode
    :mode ("\\.rs\\'" . rust-ts-mode)
    :interpreter ("rust" . rust-ts-mode)
    :hook
    (rust-ts-mode . eglot-ensure)
    :preface
    (defun smahm/rust-run ()
      "Compile current buffer file with rust."
      (interactive)
      (compile (format "rustc %s" buffer-file-name)))
    (defun smahm/rust-format ()
      "Format current buffer file with rustimports."
      (interactive)
      (compile (format "rustfmt --color never %s" buffer-file-name buffer-file-name))
      (smahm/revert-buffer-no-confirm))
    (defun smahm/rust-check ()
      "Check current buffer file with rustimports."
      (interactive)
      (compile (format "rustfmt --color never --check %s" buffer-file-name)))
    :custom
    (rust-format-save t))
#+end_src
*** Snippets
Rust specific snippets for tempel
#+begin_src lisp-data :tangle snippets/rust.eld :mkdirp yes
rust-ts-mode rust-ts-mode

#+end_src
*** Menu
We can add a menu for python specific functions
#+begin_src emacs-lisp
  (pretty-hydra-define hydra-rust
    (:hint nil :forein-keys warn :quit-key "q" :title (with-mdicon "nf-md-language_rust" "Rust" 1 -0.05))
    ("Run"
     (("r" smahm/rust-run "run"))
     "Format"
     (("f" smahm/rust-format "format")
      ("c" smahm/rust-check "check"))))
  (with-eval-after-load "rust-ts-mode"
    (define-key rust-ts-mode-map (kbd "C-c r") 'hydra-rust/body))
#+end_src
** Bash
Bash development environment.
*** Config
#+begin_src emacs-lisp
  (use-package bash
    :ensure nil
    :mode (("\\.sh\\'" . bash-ts-mode))
    :interpreter ("sh" . bash-ts-mode)
    :hook
    (bash-ts-mode . eglot-ensure)
    :init
    (add-to-list 'eglot-server-programs '((bash-ts-mode) . ("bash-language-server" "start")))
    :preface
    (defun smahm/sh-run ()
      "Compile current buffer file with sh."
      (interactive)
      (compile (format "bash %s" buffer-file-name)))
    (defun smahm/sh-format ()
      "Compile current buffer file with sh."
      (interactive)
      (compile (format "shfmt -w %s" buffer-file-name))
    (smahm/revert-buffer-no-confirm))
    (defun smahm/sh-check ()
      "Compile current buffer file with sh."
      (interactive)
      (compile (format "shellcheck %s" buffer-file-name))))
#+end_src
*** Snippets
Bash specific snippets for tempel
#+begin_src lisp-data :tangle snippets/sh.eld :mkdirp yes
  sh-mode bash-ts-mode
  (! & "#!/usr/bin/env bash" n q)
  (if "if [ " p " ]" n "  then " p n "fi" q)
  (ife "if [ " p " ]" n "  then " p n "else" p n "fi" q)
  (cs "case " p " in" n> p " )" n> p n> ";;" n> q n "esac")
  (fr "for " p " in " p n "do" n> q n "done")
#+end_src
*** Menu
We can add a menu for python specific functions
#+begin_src emacs-lisp
  (pretty-hydra-define hydra-sh
	(:hint nil :forein-keys warn :quit-key "q" :title (with-octicon "nf-oct-terminal" "sh" 1 -0.05))
	("Run"
	 (("r" smahm/sh-run "run"))
	 "Format"
	 (("f" smahm/sh-format "format")
	  ("c" smahm/sh-check "check"))))
	(define-key bash-ts-mode-map (kbd "C-c r") 'hydra-sh/body)
#+end_src
